import java.util.Scanner;class Main {  char[] array = {'a', 'b', 'c', 'd'};  public static void main(String[] args) {            Board gameObj = new Board(true);    Scanner stringScanner = new Scanner(System.in);    boolean isWhite = true;    int row1;    int col1;    int row2;    int col2;    System.out.print("\033[H\033[2J\n");        while (true) {      System.out.print("\n");      if (isWhite) {        System.out.print("White ");      } else {        System.out.print("Black ");      }      System.out.println("to move...");      gameObj.printBoard(isWhite);            System.out.print("\nenter move: ");      String moveString = stringScanner.nextLine();      try {        row1 = MoveCheckUtil.parseNotation(2, moveString);        col1 = MoveCheckUtil.parseNotation(1, moveString);        row2 = MoveCheckUtil.parseNotation(4, moveString);        col2 = MoveCheckUtil.parseNotation(3, moveString);      } catch (Exception e) {        System.out.print("\033[H\033[2J");        System.out.println("The entered move is not valid, please enter a move like \"g1 f3\".");        continue;       }      try {        gameObj.move(row1, col1, row2, col2);      } catch (IllegalMoveException e) {        System.out.print("\033[H\033[2J");        System.out.println("That move is illegal, please enter a legal move");        continue;      }      System.out.print("\033[H\033[2J\n");      isWhite = !isWhite;      if (gameObj.gameWon) {        break;      }    }    stringScanner.close();  }}class Rook extends Piece {  boolean isWhite;  char pieceChar;  public Rook(boolean isWhite) {    this.isWhite = isWhite;    if (isWhite) {      pieceChar = 'R';    } else {      pieceChar = 'r';    }  }  void moveCheck(Piece[][] board, int row1, int col1, int row2, int col2) throws IllegalArgumentException {     int linearStatus = MoveCheckUtil.linear(board, row1, col1, row2, col2);    if (linearStatus == -1) {      KingAttackedException e = new KingAttackedException("piece is attacking the king");      throw e;    } else if (linearStatus == 0) {      IllegalMoveException e = new IllegalMoveException("this move is illegal");      throw e;    }  }    char getPieceChar() {    return pieceChar;  }  boolean getIsWhite() {    return isWhite;  }}class Queen extends Piece {  boolean isWhite;  char pieceChar;  public Queen(boolean isWhite) {    this.isWhite = isWhite;    if (isWhite) {      pieceChar = 'Q';    } else {      pieceChar = 'q';    }  }  void moveCheck(Piece[][] board, int row1, int col1, int row2, int col2) throws IllegalArgumentException {     int linearStatus = MoveCheckUtil.linear(board, row1, col1, row2, col2);    if (linearStatus == -1) {      KingAttackedException e = new KingAttackedException("piece is attacking the king");      throw e;    } else if (linearStatus == 0) {      IllegalMoveException e = new IllegalMoveException("this move is illegal");      throw e;    }  }    char getPieceChar() {    return pieceChar;  }  boolean getIsWhite() {    return isWhite;  }}class Piece {  char pieceChar;  boolean isWhite;  boolean hasMoved;  void moveCheck(Piece[][] board, int row1, int col1, int row2, int col2) throws IllegalArgumentException {       }  char getPieceChar() {    return this.pieceChar;  }  boolean getIsWhite() {    return this.isWhite;  }  boolean getHasMoved() {    return this.hasMoved;  }                }class Pawn extends Piece {  boolean isWhite;  char pieceChar;  boolean hasMoved = false;   public Pawn(boolean isWhite) {    this.isWhite = isWhite;    if (isWhite) {      pieceChar = 'P';    } else {      pieceChar = 'p';    }  }  void moveCheck(Piece[][] board, int row1, int col1, int row2, int col2) throws IllegalArgumentException {     int moveStatus = MoveCheckUtil.pawn(board, row1, col1, row2, col2);    if (moveStatus == -1) {      KingAttackedException e = new KingAttackedException("piece is attacking the king");      throw e;    } else if (moveStatus == 0) {      IllegalMoveException e = new IllegalMoveException("this move is illegal");      throw e;    }  }    char getPieceChar() {    return pieceChar;  }  boolean getIsWhite() {    return isWhite;  }  boolean getHasMoved() {    return hasMoved;  }}class Knight extends Piece {  boolean isWhite;  char pieceChar;  public Knight(boolean isWhite) {    this.isWhite = isWhite;    if (isWhite) {      pieceChar = 'N';    } else {      pieceChar = 'n';    }  }  void moveCheck(Piece[][] board, int row1, int col1, int row2, int col2) throws IllegalArgumentException {     int moveStatus = MoveCheckUtil.knight(board, row1, col1, row2, col2);    if (moveStatus == -1) {      KingAttackedException e = new KingAttackedException("piece is attacking the king");      throw e;    } else if (moveStatus == 0) {      IllegalMoveException e = new IllegalMoveException("this move is illegal");      throw e;    }  }    char getPieceChar() {    return pieceChar;  }  boolean getIsWhite() {    return isWhite;  }}class King extends Piece {  boolean isWhite;  char pieceChar;  boolean hasMoved = false;   public King(boolean isWhite) {    this.isWhite = isWhite;    if (isWhite) {      pieceChar = 'K';    } else {      pieceChar = 'k';    }  }  void moveCheck(Piece[][] board, int row1, int col1, int row2, int col2) {    int moveStatus = MoveCheckUtil.king(board, row1, col1, row2, col2);    if (moveStatus == -1) {      KingAttackedException e = new KingAttackedException("piece is attacking the king");      throw e;    } else if (moveStatus == 0) {      IllegalMoveException e = new IllegalMoveException("this move is illegal");      throw e;    }  }    char getPieceChar() {    return pieceChar;  }  boolean getIsWhite() {    return isWhite;  }  boolean getHasMoved() {    return hasMoved;  }}class KingAttackedException extends RuntimeException {  public KingAttackedException(String errorMessage) {    super(errorMessage);  }}class IllegalMoveException extends RuntimeException {  public IllegalMoveException(String errorMessage) {    super(errorMessage);  }}class Board {      Piece[][] board = new Piece[8][8];  final String DEFAULT_BOARD = "rnbqkbnr                                                RNBQKBNR";      boolean gameWon = false;  public Board(boolean useDefaultBoard) {    if (useDefaultBoard) {      initilizeBoard(DEFAULT_BOARD);    }  }  void initilizeBoard(String boardString) {    for (int i = 0; i < 8; i++) {      for (int j = 0; j < 8; j++) {        char pieceChar = boardString.charAt(8*i+j);                switch (pieceChar) {           case 'P':             board[i][j] = new Pawn(true);            break;          case 'p':            board[i][j] = new Pawn(false);            break;          case 'R':             board[i][j] = new Rook(true);            break;          case 'r':            board[i][j] = new Rook(false);            break;          case 'N':             board[i][j] = new Knight(true);            break;          case 'n':            board[i][j] = new Knight(false);            break;          case 'B':             board[i][j] = new Bishop(true);            break;          case 'b':            board[i][j] = new Bishop(false);            break;          case 'Q':             board[i][j] = new Queen(true);            break;          case 'q':            board[i][j] = new Queen(false);            break;          case 'K':             board[i][j] = new King(true);            break;          case 'k':            board[i][j] = new King(false);            break;        }      }    }  }  void printBoard(boolean fromWhite) {    if (fromWhite) {      System.out.println("   A B C D E F G H");      for (int i = 0; i <= 7; i++) {        System.out.print((8 - i) + " ");        for (int j = 0; j <= 7; j++) {          try {            System.out.print("|" + board[i][j].getPieceChar());          }          catch(NullPointerException e) {             System.out.print("| ");          }        }        System.out.print("|\n");      }    } else {      System.out.println("   H G F E D C B A");      for (int i = 7; i >= 0; i--) {        System.out.print((8 - i) + " ");        for (int j = 7; j >= 0; j--) {          try {            System.out.print("|" + board[i][j].getPieceChar());          }          catch(NullPointerException e) {             System.out.print("| ");          }        }        System.out.print("|\n");      }     }  }    void move(int row1, int col1, int row2, int col2) {         try {            board[row1][col1].moveCheck(board, row1, col1, row2, col2);      board[row2][col2] = board[row1][col1];      board[row1][col1] = null;    } catch (IllegalMoveException e) {      throw e;    } catch (KingAttackedException e) {      throw e;    }  }  void testMove() {     int r1 = 3;    int c1 = 4;    int r2 = 5;    int c2 = 4;    if (MoveCheckUtil.linear(board, r1, c1, r2, c2) == 1) {       System.out.println("great success");      board[r2][c2] = board[r1][c1];      board[r1][c1] = null;    } else {      System.out.println("great un-success");    }  }}/*00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 1720 21 22 23 24 25 26 2730 31 32 33*34*35 36 3740 41 42 43 44 45 46 4750 51 52 53 54 55 56 5760 61 62 63 64 65*66*6770 71 72 73 74 75 76 77*/ class MoveCheckUtil {    static int linear(Piece[][] board, int row1, int col1, int row2, int col2) {    /*    linear() {      1. find the direction of the chosen move      2. check if the piece can move in that direction      3. use for loops to test if the move is valid    }     */        int direction = 5;        boolean isWhite = board[row1][col1].getIsWhite();    char pieceChar = board[row1][col1].getPieceChar();            if (col1 == col2 && row1 == row2) {       return 0;     } else if (col1 == col2 && row1 > row2) {       direction = 8;    } else if (col1 == col2 && row1 < row2) {       direction = 2;    } else if (col1 > col2 && row1 == row2) {       direction = 4;    } else if (col1 < col2 && row1 == row2) {       direction = 6;    }        else if (!(Math.abs(row1 - row2) == Math.abs(col1 - col2))) {       return 0;     } else if (row1 > row2 && col1 > col2) {       direction = 7;    } else if (row1 > row2 && col1 < col2) {       direction = 9;    } else if (row1 < row2 && col1 > col2) {       direction = 1;    } else if (row1 < row2 && col1 < col2) {       direction = 3;    }        if (!validDirection(direction, pieceChar)) {      return 0;     }    int j = 0;         switch (direction) {      case 8:         for (int i = row1; i >= row2; i--) {           if (i == row1) {             continue;          }          else if (!(board[i][col1] instanceof Piece)) {             continue;          }           else if (board[i][col1].getIsWhite() == isWhite) {             return 0;           }          if (board[i][col1].getPieceChar() == 'K' || board[i][col1].getPieceChar() == 'k') {             return -1;           }          else if (i-1 >= row2) {             return 0;           }        }        return 1;       case 2:         for (int i = row1; i <= row2; i++) {          if (i == row1) {             continue;          }          else if (!(board[i][col1] instanceof Piece)) {             continue;          }           else if (board[i][col1].getIsWhite() == isWhite) {             return 0;           }          if (board[i][col1].getPieceChar() == 'K' || board[i][col1].getPieceChar() == 'k') {             return -1;           }          else if (i+1 >= row2) {             return 0;           }        }        return 1;       case 4:         for (int i = col1; i >= col2; i--) {          if (i == col1) {             continue;          }          else if (!(board[row1][i] instanceof Piece)) {             continue;          }           else if (board[row1][i].getIsWhite() == isWhite) {             return 0;           }          if (board[row1][i].getPieceChar() == 'K' || board[row1][i].getPieceChar() == 'k') {             return -1;           }          else if (i-1 >= col2) {             return 0;           }        }        return 1;       case 6:         for (int i = col1; i <= col2; i++) {          if (i == col1) {             continue;          }          else if (!(board[row1][i] instanceof Piece)) {             continue;          }           else if (board[row1][i].getIsWhite() == isWhite) {             return 0;           }          if (board[row1][i].getPieceChar() == 'K' || board[row1][i].getPieceChar() == 'k') {             return -1;           }          else if (i+1 <= col2) {             return 0;           }        }        return 1;                   case 7:         j = col1;        for (int i = row1; i >= row2; i--, j--) {           if (i == row1) {             continue;          }          else if (!(board[i][j] instanceof Piece)) {             continue;          }           else if (board[i][j].getIsWhite() == isWhite) {             return 0;           }          if (board[i][j].getPieceChar() == 'K' || board[i][j].getPieceChar() == 'k') {             return -1;           }          else if (i-1 >= row2) {             return 0;           }        }        return 1;       case 9:         j = col1;        for (int i = row1; i >= row2; i--, j++) {           if (i == row1) {             continue;          }          else if (!(board[i][j] instanceof Piece)) {             continue;          }           else if (board[i][j].getIsWhite() == isWhite) {             return 0;           }          if (board[i][j].getPieceChar() == 'K' || board[i][j].getPieceChar() == 'k') {             return -1;           }          else if (i-1 >= row2) {             return 0;           }        }        return 1;       case 1:         j = col1;        for (int i = row1; i <= row2; i++, j--) {           if (i == row1) {             continue;          }          else if (!(board[i][j] instanceof Piece)) {             continue;          }           else if (board[i][j].getIsWhite() == isWhite) {             return 0;           }          if (board[i][j].getPieceChar() == 'K' || board[i][j].getPieceChar() == 'k') {             return -1;           }          else if (i+1 <= row2) {             return 0;           }        }        return 1;             case 3:         j = col1;        for (int i = row1; i >= row2; i--, j--) {           if (i == row1) {             continue;          }          else if (!(board[i][j] instanceof Piece)) {             continue;          }           else if (board[i][j].getIsWhite() == isWhite) {             return 0;           }          if (board[i][j].getPieceChar() == 'K' || board[i][j].getPieceChar() == 'k') {             return -1;           }          else if (i-1 >= row2) {             return 0;           }        }        return 1;     }    return 0;  }    static int king(Piece[][] board, int row1, int col1, int row2, int col2) {    if (row1 == row2 && col1 == col2) {      return 0;     } else if (Math.abs(row1 - row2) > 1 || Math.abs(col1 - col2) > 1) {      return 0;     } else if (board[row1][col1].getIsWhite() == board[row2][col2].getIsWhite()) {      return 0;     } else {      return 1;    }  }    static int knight(Piece[][] board, int row1, int col1, int row2, int col2) {    if (board[row1][col1].getIsWhite() == board[row2][col2].getIsWhite()) {      return 0;    } else if (row1 + 2 == row2 && col1 + 1 == col2) {      return 1;    } else if (row1 - 2 == row2 && col1 + 1 == col2) {      return 1;    } else if (row1 + 2 == row2 && col1 - 1 == col2) {      return 1;    } else if (row1 - 2 == row2 && col1 - 1 == col2) {      return 1;    } else if (row1 + 1 == row2 && col1 + 2 == col2) {      return 1;    } else if (row1 - 1 == row2 && col1 + 2 == col2) {      return 1;    } else if (row1 + 1 == row2 && col1 - 2 == col2) {      return 1;    } else if (row1 - 1 == row2 && col1 - 2 == col2) {      return 1;    } else {      return 0;    }  }    static int pawn(Piece[][] board, int row1, int col1, int row2, int col2) {        if (board[row1][col1].getIsWhite() == board[row2][col2].getIsWhite()) {      return 0;     }    if (!(board[row2][col2] instanceof Piece)) {       if (col1 != col2) {        return 0;       } else if (!board[row1][col1].getHasMoved() && row1 - row2 == 2) {         return 1;      }    }    return 1;  }    static boolean validDirection(int direction, char pieceChar) {    switch (pieceChar) {      case 'R':       case 'r':        switch (direction) {          case 8:          case 2:          case 4:          case 6:            return true;          default:            return false;        }      case 'B':       case 'b':        switch (direction) {          case 7:          case 9:          case 1:          case 3:            return true;          default:            return false;        }      case 'Q':       case 'q':        return true;      default:        return false;    }  }    static void movePiece(Piece[][] board, int row1, int col1, int row2, int col2) {    board[row1][col1] = board[row1][col1];    board[row1][col1] = null;  }  static int parseNotation(int returnAxis, String notation) {        int number = -1;    switch (returnAxis) {      case 1:        number = notation.charAt(0) - 97;        break;      case 2:        number = 7 - (notation.charAt(1) - 49);        break;      case 3:        number = notation.charAt(3) - 97;        break;      case 4:        number = 7 - (notation.charAt(4) - 49);        break;    }    if (number < 0 || number > 7 || notation.length() != 5) {      IllegalArgumentException e = new IllegalArgumentException("the move is out of bounds");      throw e;    }    return number;  }}class Bishop extends Piece {  boolean isWhite;  char pieceChar;  public Bishop(boolean isWhite) {    this.isWhite = isWhite;    if (isWhite) {      pieceChar = 'B';    } else {      pieceChar = 'b';    }  }  void moveCheck(Piece[][] board, int row1, int col1, int row2, int col2) throws IllegalArgumentException {     int linearStatus = MoveCheckUtil.linear(board, row1, col1, row2, col2);    if (linearStatus == -1) {      KingAttackedException e = new KingAttackedException("piece is attacking the king");      throw e;    } else if (linearStatus == 0) {      IllegalMoveException e = new IllegalMoveException("this move is illegal");      throw e;    }  }    char getPieceChar() {    return pieceChar;  }  boolean getIsWhite() {    return isWhite;  }}